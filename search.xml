<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blockqueue</title>
      <link href="//pages/c006/"/>
      <url>//pages/c006/</url>
      
        <content type="html"><![CDATA[<h2 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h2><ol><li>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</li><li>DelayQueue：使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：不存储元素的阻塞队列。</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ol><p><img src="/pages/c006/a.png" alt="img">  </p><h3 id="1-ArrayBlockingQueue（公平、非公平）"><a href="#1-ArrayBlockingQueue（公平、非公平）" class="headerlink" title="1.ArrayBlockingQueue（公平、非公平）"></a>1.ArrayBlockingQueue（公平、非公平）</h3><p>用数组实现的<strong>有界阻塞队列</strong>。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下<br>不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当<br>队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入<br>元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐<br>量。我们可以使用以下代码创建一个公平的阻塞队列：<br><code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);</code>  </p><h3 id="2-LinkedBlockingQueue（两个独立锁提高并发）"><a href="#2-LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="2.LinkedBlockingQueue（两个独立锁提高并发）"></a>2.LinkedBlockingQueue（两个独立锁提高并发）</h3><p>基于链表的阻塞队列，同<code> ArrayListBlockingQueue</code> 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了<code>独立的锁</code>来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h3 id="3-PriorityBlockingQueue（compareTo-排序实现优先）"><a href="#3-PriorityBlockingQueue（compareTo-排序实现优先）" class="headerlink" title="3.PriorityBlockingQueue（compareTo 排序实现优先）"></a>3.PriorityBlockingQueue（compareTo 排序实现优先）</h3><p>是 一 个 支持 优 先级 的 无界 队 列 。默 认 情况 下 元素 采 取 自然 顺 序升 序 排列 。 可 以自 定 义实 现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code> PriorityBlockingQueue</code> 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 </p><h3 id="4-DelayQueue（缓存失效、定时任务-）"><a href="#4-DelayQueue（缓存失效、定时任务-）" class="headerlink" title="4.DelayQueue（缓存失效、定时任务 ）"></a>4.DelayQueue（缓存失效、定时任务 ）</h3><p>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 <code>DelayQueue</code> 运用在以下应用场景：  </p><ol><li>缓存系统的设计：可以用 <code>DelayQueue</code> 保存缓存元素的有效期，使用一个线程循环查询<br><code>DelayQueue</code>，一旦能从 <code>DelayQueue</code> 中获取元素时，表示缓存有效期到了。  </li><li>定 时 任 务 调 度 ： 使 用 <code>DelayQueue</code> 保 存 当 天 将 会 执 行 的 任 务 和 执 行 时 间 ， 一 旦 从<code>DelayQueue</code> 中获取到任务就开始执行，从比如 <code>TimerQueue</code> 就是使用 <code>DelayQueue</code> 实现的  </li></ol><h3 id="5-SynchronousQueue（不存储数据、可用于传递数据）"><a href="#5-SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="5.SynchronousQueue（不存储数据、可用于传递数据）"></a>5.SynchronousQueue（不存储数据、可用于传递数据）</h3><p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。  </p><h3 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6.LinkedTransferQueue"></a>6.LinkedTransferQueue</h3><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，<br>LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。  </p><ol><li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的<br>poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如<br>果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素<br>被消费者消费了才返回。  </li><li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费<br>者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否<br>接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传<br>入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时<br>还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。  <h3 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7.LinkedBlockingDeque"></a>7.LinkedBlockingDeque</h3>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他 的 阻 塞 队 列 ， LinkedBlockingDeque 多 了 addFirst ， addLast ， offerFirst ， offerLast ，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。  <h2 id="CyclicBarrier、CountDownLatch、Semaphore-的用法"><a href="#CyclicBarrier、CountDownLatch、Semaphore-的用法" class="headerlink" title="CyclicBarrier、CountDownLatch、Semaphore 的用法"></a>CyclicBarrier、CountDownLatch、Semaphore 的用法</h2><h3 id="1-CountDownLatch（线程计数器-）"><a href="#1-CountDownLatch（线程计数器-）" class="headerlink" title="1.CountDownLatch（线程计数器 ）"></a>1.CountDownLatch（线程计数器 ）</h3>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"正在执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待 2 个子线程执行完毕..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2 个子线程已经执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"继续执行主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）"><a href="#2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）" class="headerlink" title="2.CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）"></a>2.CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）</h3>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环<br>是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做<br>barrier，当调用 await()方法之后，线程就处于 barrier 了。<br>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：  </li><li>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任<br>务；  </li><li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有<br>线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。<br>具体使用如下，另外 CyclicBarrier 是可以重用的。  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">new</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Writer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">CyclicBarrier</span> cyclicBarrier<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span><span class="token class-name">CyclicBarrier</span> cyclicBarrier<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cyclicBarrier <span class="token operator">=</span> cyclicBarrier<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//以睡眠来模拟线程需要预定写入数据操作</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 线 程 "</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>" 写 入 数 据 完                    毕，等待其他线程写入完毕"<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有线程写入完毕，继续处理其他任务，比如数据操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Semaphore（信号量-控制同时访问的线程个数）"><a href="#3-Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="3.Semaphore（信号量-控制同时访问的线程个数）"></a>3.Semaphore（信号量-控制同时访问的线程个数）</h3>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过<br>acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>Semaphore 类中比较重要的几个方法：  </li><li>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许<br>可。  </li><li>public void acquire(int permits):获取 permits 个许可  </li><li>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。  </li><li>public void release(int permits) { }:释放 permits 个许可  </li></ol><p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法  </p><ol><li>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失<br>败，则立即返回 false  </li><li>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的<br>时间内获取成功，则立即返回 true，否则则立即返回 false  </li><li>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返<br>回 true，若获取失败，则立即返回 false  </li><li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits<br>个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false  </li><li>还可以通过 availablePermits()方法得到可用的许可数目。  </li></ol><p>例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">//工人数</span>    <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//机器数目</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>semaphore<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Semaphore</span> semaphore<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span><span class="token class-name">Semaphore</span> semaphore<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>semaphore <span class="token operator">=</span> semaphore<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工人"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">+</span><span class="token string">"占用一个机器在生产..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工人"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">+</span><span class="token string">"释放出机器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不<br>同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时<br>执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h2 id="volatile-关键字的作用（变量可见性、禁止重排序）"><a href="#volatile-关键字的作用（变量可见性、禁止重排序）" class="headerlink" title="volatile 关键字的作用（变量可见性、禁止重排序）"></a>volatile 关键字的作用（变量可见性、禁止重排序）</h2><p>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他<br>线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的<br>地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。<br><strong>变量可见性</strong><br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的<br>值对于其他线程是可以立即获取的。<br>**禁止重排序 **<br>volatile 禁止了指令重排。<br>比 sychronized 更轻量级的同步锁<br>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一<br>种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共<br>享，线程直接给这个变量赋值。<br><img src="/pages/c006/b.png" alt="img"><br>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有<br>多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU<br>cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache<br>这一步。<br><em>适用场景</em><br>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，<br>但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以<br>代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安<br>全：<br>（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean<br>flag = true）。<br>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不<br>能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。  </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的高频问题</title>
      <link href="/2022/01/23/interview-mysql/"/>
      <url>/2022/01/23/interview-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL-索引底层结构为什么使用-B-树？"><a href="#1-MySQL-索引底层结构为什么使用-B-树？" class="headerlink" title="1.MySQL 索引底层结构为什么使用 B+树？"></a>1.MySQL 索引底层结构为什么使用 B+树？</h2><ul><li>哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支<br>持，最终导致全表扫描；B 树能够在非叶节子点中存储数据，但是这也导致在查询连续数<br>据时可能会带来更多的随机 I/O，而 B+树的所有叶节点可以通过指针相互连接，能够减<br>少顺序遍历时产生的额外随机 I/O；</li><li>第一，B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节<br>点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。</li><li>第二，B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。</li></ul><h2 id="2-MVCC-是什么？它的底层原理是什么？"><a href="#2-MVCC-是什么？它的底层原理是什么？" class="headerlink" title="2.MVCC 是什么？它的底层原理是什么？"></a>2.MVCC 是什么？它的底层原理是什么？</h2><p>MVCC，多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并<br>发性能的一种机制。  </p><ul><li>事务版本号</li><li>表的隐藏列</li><li>undo log</li><li>read view  </li></ul><h2 id="3-索引失效的情况有哪些？"><a href="#3-索引失效的情况有哪些？" class="headerlink" title="3.索引失效的情况有哪些？"></a>3.索引失效的情况有哪些？</h2><ul><li>like 以%开头索引无效，当 like 以&amp;结尾，索引有效。</li><li>or 语句前后没有同事使用索引，当且仅当 or 语句查询条件的前后列均为索引时，索引生<br>效。</li><li>组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。</li><li>数据类型出现隐式转换，如 varchar 不加单引号的时候可能会自动转换为 int 类型，这个<br>时候索引失效。</li><li>在索引列上使用 IS NULL 或者 IS NOT NULL 时候，索引失效，因为索引是不索引空值<br>得。</li><li>在索引字段上使用，NOT、 &lt;&gt;、！= 、时候是不会使用索引的，对于这样的处理只会进<br>行全表扫描。</li><li>对索引字段进行计算操作，函数操作时不会使用索引。</li><li>当全表扫描速度比索引速度快的时候不会使用索引。  </li></ul><h2 id="4-Redis-主从同步是怎么实现的？"><a href="#4-Redis-主从同步是怎么实现的？" class="headerlink" title="4.Redis 主从同步是怎么实现的？"></a>4.Redis 主从同步是怎么实现的？</h2><p>全量同步<br>master 服务器会开启一个后台进程用于将 redis 中的数据生成一个 rdb 文件，与此同时，服<br>务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该 rdb 文件传递给 slave 服务器，而 slave 服务器会将 rdb 文件保存在磁盘并通过读<br>取该文件将数据加载到内存，在此之后 master 服务器会将在此期间缓存的命令通过 redis 传输协议发送给 slave 服务器，然后 slave 服务器将这些命令依次作用于自己<br>本地的数据集上最终达到数据的一致性。<br>增量同步<br>从 redis 2.8 版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master 服务<br>器和 slave 服务器之间都是进行全量数据同步。<br>从 redis 2.8 开始，即使主从连接中途断掉，也不需要进行全量同步，因为从这个版本开始融<br>入了部分同步的概念。部分同步的实现依赖于在 master 服务器内存中给每个 slave 服务器维<br>护了一份同步日志和同步标识，每个 slave 服务器在跟 master 服务器进行同步时都会携带自<br>己的同步标识和上次同步的最后位置。当主从连接断掉之后，slave 服务器隔断时间（默认<br>1s）主动尝试和 master 服务器进行连接，如果从服务器携带的偏移量标识还在 master 服务<br>器上的同步备份日志中，那么就从 slave 发送的偏移量开始继续上次的同步操作，如果 slave<br>发送的偏移量已经不再 master 的同步备份日志中（可能由于主从之间断掉的时间比较长或者<br>在断掉的短暂时间内 master 服务器接收到大量的写操作），则必须进行一次全量更新。在部<br>分同步过程中，master 会将本地记录的同步备份日志中记录的指令依次发送给 slave 服务器<br>从而达到数据一致。<br>Redis 主从同步策略<br>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，<br>slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同<br>步，如不成功，要求从机进行全量同步。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS和AQS</title>
      <link href="//pages/c005/"/>
      <url>//pages/c005/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是CAS（比较并交换-乐观锁机制-锁自旋）？"><a href="#1-什么是CAS（比较并交换-乐观锁机制-锁自旋）？" class="headerlink" title="1.什么是CAS（比较并交换-乐观锁机制-锁自旋）？"></a>1.什么是CAS（比较并交换-乐观锁机制-锁自旋）？</h2><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数<br>CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等<br>于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当<br>前线程什么都不做。最后，CAS 返回当前 V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时<br>使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂<br>起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，<br>CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。  </p><h3 id="原子包-java-util-concurrent-atomic（锁自旋）"><a href="#原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="原子包 java.util.concurrent.atomic（锁自旋）"></a>原子包 java.util.concurrent.atomic（锁自旋）</h3><p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就<br>是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个<br>线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等<br>到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。<br>相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切<br>换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//CAS 自旋，一直尝试，直达成功</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> current<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getAndIncrement</code> 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行<br>CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成<br>CPU 指令的操作。</p><h3 id="ABA问题？"><a href="#ABA问题？" class="headerlink" title="ABA问题？"></a>ABA问题？</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时<br>刻比较并替换，那么在这个时间差类会导致数据的变化。<br>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且<br>two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操<br>作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过<br>程就是没有问题的。<br>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修<br>改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本<br>号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问<br>题，因为版本号只会增加不会减少。  </p><h2 id="2-什么是-AQS（抽象的队列同步器）"><a href="#2-什么是-AQS（抽象的队列同步器）" class="headerlink" title="2.什么是 AQS（抽象的队列同步器）"></a>2.什么是 AQS（抽象的队列同步器）</h2><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问<br>共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。<br><img src="/pages/c005/a.png" alt="aqs"><br>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被<br>阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的<br>访问方式有三种:  </p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState() </li></ul><p>AQS 定义两种资源共享方式<br><strong>Exclusive 独占资源-ReentrantLock</strong><br>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）<br><strong>Share 共享资源-Semaphore/CountDownLatch</strong><br>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。<br>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个<br>接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成<br>abstract ， 是 因 为 独 占 模 式 下 只 用 实 现 tryAcquire-tryRelease ， 而 共 享 模 式 下 只 用 实 现<br>tryAcquireShared-tryReleaseShared。如果都定义成 abstract，那么每个模式也要去实现另一模<br>式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实<br>现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/<br>唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：  </p><ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余<br>可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<br>true，否则返回 false。  </li></ol><p><em>同步器的实现是 ABS 核心（state 资源状态计数）</em><br>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程<br>lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失<br>败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放<br>锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，<br>获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。<br>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与<br>线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state<br>会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程<br>就会从 await()函数返回，继续后余动作。<br>ReentrantReadWriteLock 实现独占和共享两种方式<br>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-<br>tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器<br>同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的双重校验锁</title>
      <link href="//pages/c004/"/>
      <url>//pages/c004/</url>
      
        <content type="html"><![CDATA[<h2 id="1-示例代码-线程安全"><a href="#1-示例代码-线程安全" class="headerlink" title="1.示例代码 (线程安全)"></a>1.示例代码 (线程安全)</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，需要注意 <code>uniqueInstance</code> 采用<code>volatile</code>关键字修饰也是很有必要。<br><code>uniqueInstance</code> 采用<code> volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这<br>段代码其实是分为三步执行：  </p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不<br>会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执<br>行了 1 和 3，此时 T2 调用 <code>getUniqueInstance ()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回<br><code>uniqueInstance </code>，但此时 <code>uniqueInstance</code> 还未被初始化。使用<code> volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。    </li></ol><h2 id="2-说一下对synchronized关键字的理解？"><a href="#2-说一下对synchronized关键字的理解？" class="headerlink" title="2.说一下对synchronized关键字的理解？"></a>2.说一下对synchronized关键字的理解？</h2><p><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性， <code>synchronized</code> 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中， <code>synchronized</code> 属于 重量级锁，效率低下。<br>为什么呢？<br>因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映<br>射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而<br>操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较<br>⻓的时间，时间成本相对较高。<br>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的<br><code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适<br>应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。  </p><h2 id="3-怎么使用synchronized关键字的？"><a href="#3-怎么使用synchronized关键字的？" class="headerlink" title="3.怎么使用synchronized关键字的？"></a>3.怎么使用synchronized关键字的？</h2><p>synchronized 关键字最主要的三种使用方式：<br>1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当<br>前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个<br>静态资源，不管 new 了多少个对象，只有一份）。所以，如果一个线程 A 调用一个实例对象的<br>非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，<br>是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访<br>问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.修饰代码块 ：指定加锁对象，对给定对象/类加锁。 <code>synchronized(this|object)</code> 表示进入同步代码<br>库前要获得给定对象的锁。 <code>synchronized(类.class)</code> 表示进入同步代码前要获得 当前 class 的锁<br><strong>总结</strong>  </p><ul><li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class<br>类上锁。</li><li>synchronized 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！  </li></ul><h2 id="4-synchronized底层原理？"><a href="#4-synchronized底层原理？" class="headerlink" title="4.synchronized底层原理？"></a>4.synchronized底层原理？</h2><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和<code> monitorexit</code> 指令，其中<br><code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束位<br>置。<br><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是<br><code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。<br><strong>不过两者的本质都是对对象监视器 <code>monitor</code> 的获取。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客解决图片不显示问题</title>
      <link href="//pages/c003/"/>
      <url>//pages/c003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于在使用hexo搭建博客过程中遇到了图片不显示的问题，本篇就详细解释一下。（windows）  </p></blockquote><p>在项目根目录下打开cmd，输入<code>hexo new xxx</code>之后会在根目录下创建一个xxx.md文件和xxx的文件夹，我们可以把<br>图片放到xxx文件夹内，然后在xxx.md文件内引入，引入的方式如下：  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>test<span class="token punctuation">]</span><span class="token punctuation">(</span>test.png<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>是不需要带上相对路径的</em><br><strong>但是它有一些前提条件！！！</strong></p><ol><li>安装插件，在项目根目录下打开cmd，然后输入下面命令<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改主页配置文件，把_config.yml里的post_asset_folder:这个选项设置为true</li><li>使用<code>hexo new xxx</code>来生成博客和它的文件夹，图片就放到相应的文件夹即可<blockquote><p>测试一下</p></blockquote></li></ol><p><img src="/pages/c003/a.jpg" alt="test"></p>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的分布式锁简单实现</title>
      <link href="//pages/c002/"/>
      <url>//pages/c002/</url>
      
        <content type="html"><![CDATA[<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，<br>这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，<br>这就是分布式锁要解决的问题！<br>分布式锁主流实现方案：  </p><ul><li>基于数据库实现分布式锁</li><li>基于缓存(Redis)</li><li>基于Zookeeper  </li></ul><p>每一种分布式锁解决方案都有各自的优缺点：</p><ul><li>性能：Redis最高</li><li>可靠性：zookeeper最高<blockquote><p>下面讲一下基于redis实现的分布式锁</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> lock <span class="token number">200</span> nx ex <span class="token number">10</span><span class="token comment"># EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</span><span class="token comment"># PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</span><span class="token comment"># NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</span><span class="token comment"># XX ：只在键已经存在时，才对键进行设置操作。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/pages/c002/c002_01.png" alt="dis1">  </li></ul><ol><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试  <blockquote><p>示例代码：</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//1获取锁，setnx</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2获取锁成功、查询num的值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//2.4释放锁，del</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token comment">//3获取锁失败、每隔0.1秒再获取</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>解决：设置lock过期时间，自动释放锁。  <blockquote><p>优化，设置锁的过期时间  </p></blockquote></li></ol><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）<br><img src="/pages/c002/c002_02.png" alt="dis2"><br>示例代码：  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//在redis中使用setnx  设置lock,并且设置过期时间3秒</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"chenjian"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此处模拟业务异常情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">==</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4 释放锁</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>问题：可能会释放其他服务器的锁。 </li></ol><p> 场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑 </li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p> 最终等于没锁的情况。<br> <strong>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</strong></p><blockquote><p>优化之UUID防误删</p></blockquote><p><img src="/pages/c002/c002_03.png" alt="dis3"><br>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在redis中使用setnx  设置lock,并且设置过期时间3秒</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此处模拟业务异常情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">==</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4 释放锁</span>        <span class="token class-name">String</span> lockValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建hexo+github博客</title>
      <link href="//pages/c001/"/>
      <url>//pages/c001/</url>
      
        <content type="html"><![CDATA[<ul><li>首先使用如下命令安装hexo-cli，看名字就知道Hexo的CLI工具；</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装成功后初始化一个博客目录，并进入该目录，然后安装依赖；</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 初始化博客目录</span>hexo init website-hexo<span class="token comment"># 进入博客目录</span><span class="token builtin class-name">cd</span> website-hexo<span class="token comment"># 安装博客相关依赖</span><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这样一个基本的博客网站就搭建完毕了，是不是秒建博客网站，然后使用如下命令启动博客网站:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>启动成功后我们可以访问下主页，用过Hexo的朋友应该知道，Hexo要搭配主题来使用，否则真的很丑，访问地址：<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="/pages/c001/blog.png" alt="myblog"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/10/hello-world/"/>
      <url>/2022/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
