<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql的高频问题</title>
      <link href="/2022/01/23/interview-mysql/"/>
      <url>/2022/01/23/interview-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL-索引底层结构为什么使用-B-树？"><a href="#1-MySQL-索引底层结构为什么使用-B-树？" class="headerlink" title="1.MySQL 索引底层结构为什么使用 B+树？"></a>1.MySQL 索引底层结构为什么使用 B+树？</h2><ul><li>哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支<br>持，最终导致全表扫描；B 树能够在非叶节子点中存储数据，但是这也导致在查询连续数<br>据时可能会带来更多的随机 I/O，而 B+树的所有叶节点可以通过指针相互连接，能够减<br>少顺序遍历时产生的额外随机 I/O；</li><li>第一，B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节<br>点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。</li><li>第二，B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。</li></ul><h2 id="2-MVCC-是什么？它的底层原理是什么？"><a href="#2-MVCC-是什么？它的底层原理是什么？" class="headerlink" title="2.MVCC 是什么？它的底层原理是什么？"></a>2.MVCC 是什么？它的底层原理是什么？</h2><p>MVCC，多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并<br>发性能的一种机制。  </p><ul><li>事务版本号</li><li>表的隐藏列</li><li>undo log</li><li>read view  </li></ul><h2 id="3-索引失效的情况有哪些？"><a href="#3-索引失效的情况有哪些？" class="headerlink" title="3.索引失效的情况有哪些？"></a>3.索引失效的情况有哪些？</h2><ul><li>like 以%开头索引无效，当 like 以&amp;结尾，索引有效。</li><li>or 语句前后没有同事使用索引，当且仅当 or 语句查询条件的前后列均为索引时，索引生<br>效。</li><li>组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。</li><li>数据类型出现隐式转换，如 varchar 不加单引号的时候可能会自动转换为 int 类型，这个<br>时候索引失效。</li><li>在索引列上使用 IS NULL 或者 IS NOT NULL 时候，索引失效，因为索引是不索引空值<br>得。</li><li>在索引字段上使用，NOT、 &lt;&gt;、！= 、时候是不会使用索引的，对于这样的处理只会进<br>行全表扫描。</li><li>对索引字段进行计算操作，函数操作时不会使用索引。</li><li>当全表扫描速度比索引速度快的时候不会使用索引。  </li></ul><h2 id="4-Redis-主从同步是怎么实现的？"><a href="#4-Redis-主从同步是怎么实现的？" class="headerlink" title="4.Redis 主从同步是怎么实现的？"></a>4.Redis 主从同步是怎么实现的？</h2><p>全量同步<br>master 服务器会开启一个后台进程用于将 redis 中的数据生成一个 rdb 文件，与此同时，服<br>务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该 rdb 文件传递给 slave 服务器，而 slave 服务器会将 rdb 文件保存在磁盘并通过读<br>取该文件将数据加载到内存，在此之后 master 服务器会将在此期间缓存的命令通过 redis 传输协议发送给 slave 服务器，然后 slave 服务器将这些命令依次作用于自己<br>本地的数据集上最终达到数据的一致性。<br>增量同步<br>从 redis 2.8 版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master 服务<br>器和 slave 服务器之间都是进行全量数据同步。<br>从 redis 2.8 开始，即使主从连接中途断掉，也不需要进行全量同步，因为从这个版本开始融<br>入了部分同步的概念。部分同步的实现依赖于在 master 服务器内存中给每个 slave 服务器维<br>护了一份同步日志和同步标识，每个 slave 服务器在跟 master 服务器进行同步时都会携带自<br>己的同步标识和上次同步的最后位置。当主从连接断掉之后，slave 服务器隔断时间（默认<br>1s）主动尝试和 master 服务器进行连接，如果从服务器携带的偏移量标识还在 master 服务<br>器上的同步备份日志中，那么就从 slave 发送的偏移量开始继续上次的同步操作，如果 slave<br>发送的偏移量已经不再 master 的同步备份日志中（可能由于主从之间断掉的时间比较长或者<br>在断掉的短暂时间内 master 服务器接收到大量的写操作），则必须进行一次全量更新。在部<br>分同步过程中，master 会将本地记录的同步备份日志中记录的指令依次发送给 slave 服务器<br>从而达到数据一致。<br>Redis 主从同步策略<br>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，<br>slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同<br>步，如不成功，要求从机进行全量同步。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS和AQS</title>
      <link href="//pages/c005/"/>
      <url>//pages/c005/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是CAS（比较并交换-乐观锁机制-锁自旋）？"><a href="#1-什么是CAS（比较并交换-乐观锁机制-锁自旋）？" class="headerlink" title="1.什么是CAS（比较并交换-乐观锁机制-锁自旋）？"></a>1.什么是CAS（比较并交换-乐观锁机制-锁自旋）？</h2><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数<br>CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等<br>于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当<br>前线程什么都不做。最后，CAS 返回当前 V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时<br>使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂<br>起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，<br>CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。  </p><h3 id="原子包-java-util-concurrent-atomic（锁自旋）"><a href="#原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="原子包 java.util.concurrent.atomic（锁自旋）"></a>原子包 java.util.concurrent.atomic（锁自旋）</h3><p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就<br>是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个<br>线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等<br>到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。<br>相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切<br>换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：  </p><pre><code class="java">public class AtomicInteger extends Number implements java.io.Serializable &#123;    private volatile int value;    public final int get() &#123;        return value;    &#125;    public final int getAndIncrement() &#123;        for (;;) &#123; //CAS 自旋，一直尝试，直达成功            int current = get();            int next = current + 1;            if (compareAndSet(current, next))                return current;        &#125;    &#125;    public final boolean compareAndSet(int expect, int update) &#123;        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    &#125;   &#125;</code></pre><p><code>getAndIncrement</code> 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行<br>CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成<br>CPU 指令的操作。</p><h3 id="ABA问题？"><a href="#ABA问题？" class="headerlink" title="ABA问题？"></a>ABA问题？</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时<br>刻比较并替换，那么在这个时间差类会导致数据的变化。<br>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且<br>two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操<br>作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过<br>程就是没有问题的。<br>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修<br>改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本<br>号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问<br>题，因为版本号只会增加不会减少。  </p><h2 id="2-什么是-AQS（抽象的队列同步器）"><a href="#2-什么是-AQS（抽象的队列同步器）" class="headerlink" title="2.什么是 AQS（抽象的队列同步器）"></a>2.什么是 AQS（抽象的队列同步器）</h2><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问<br>共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。<br><img src="/pages/c005/a.png" alt="aqs"><br>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被<br>阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的<br>访问方式有三种:  </p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState() </li></ul><p>AQS 定义两种资源共享方式<br><strong>Exclusive 独占资源-ReentrantLock</strong><br>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）<br><strong>Share 共享资源-Semaphore/CountDownLatch</strong><br>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。<br>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个<br>接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成<br>abstract ， 是 因 为 独 占 模 式 下 只 用 实 现 tryAcquire-tryRelease ， 而 共 享 模 式 下 只 用 实 现<br>tryAcquireShared-tryReleaseShared。如果都定义成 abstract，那么每个模式也要去实现另一模<br>式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实<br>现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/<br>唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：  </p><ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余<br>可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<br>true，否则返回 false。  </li></ol><p><em>同步器的实现是 ABS 核心（state 资源状态计数）</em><br>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程<br>lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失<br>败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放<br>锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，<br>获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。<br>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与<br>线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state<br>会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程<br>就会从 await()函数返回，继续后余动作。<br>ReentrantReadWriteLock 实现独占和共享两种方式<br>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-<br>tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器<br>同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的双重校验锁</title>
      <link href="//pages/c004/"/>
      <url>//pages/c004/</url>
      
        <content type="html"><![CDATA[<h2 id="1-示例代码-线程安全"><a href="#1-示例代码-线程安全" class="headerlink" title="1.示例代码 (线程安全)"></a>1.示例代码 (线程安全)</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>```    另外，需要注意 `uniqueInstance` 采用` <span class="token keyword">volatile</span> `关键字修饰也是很有必要。`uniqueInstance` 采用` <span class="token keyword">volatile</span>` 关键字修饰也是很有必要的， `uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>` 这段代码其实是分为三步执行：  <span class="token number">1.</span> 为 `uniqueInstance` 分配内存空间<span class="token number">2.</span> 初始化 `uniqueInstance`<span class="token number">3.</span> 将 `uniqueInstance` 指向分配的内存地址  但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 <span class="token number">1</span><span class="token operator">-></span><span class="token number">3</span><span class="token operator">-></span><span class="token number">2</span>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 <span class="token number">1</span> 和 <span class="token number">3</span>，此时 T2 调用 `getUniqueInstance <span class="token punctuation">(</span><span class="token punctuation">)</span>` 后发现 `uniqueInstance` 不为空，因此返回`uniqueInstance `，但此时 `uniqueInstance` 还未被初始化。使用` <span class="token keyword">volatile</span>` 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。  ## <span class="token number">2.</span>说一下对<span class="token keyword">synchronized</span>关键字的理解？`<span class="token keyword">synchronized</span>` 关键字解决的是多个线程之间访问资源的同步性， `<span class="token keyword">synchronized</span>` 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。  另外，在 <span class="token class-name">Java</span> 早期版本中， `<span class="token keyword">synchronized</span>` 属于 重量级锁，效率低下。  为什么呢？  因为监视器锁（monitor）是依赖于底层的操作系统的 <span class="token class-name">Mutex</span> <span class="token class-name">Lock</span> 来实现的，<span class="token class-name">Java</span> 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较⻓的时间，时间成本相对较高。庆幸的是在 <span class="token class-name">Java</span> <span class="token number">6</span> 之后 <span class="token class-name">Java</span> 官方对从 JVM 层面对 <span class="token keyword">synchronized</span> 较大优化，所以现在的`<span class="token keyword">synchronized</span>` 锁效率也优化得很不错了。JDK1<span class="token punctuation">.</span><span class="token number">6</span> 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。## <span class="token number">3.</span>怎么使用<span class="token keyword">synchronized</span>关键字的？<span class="token keyword">synchronized</span> 关键字最主要的三种使用方式：  <span class="token number">1.</span>修饰实例方法<span class="token operator">:</span> 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁  ```java<span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span>```  <span class="token number">2.</span>修饰静态方法<span class="token operator">:</span> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 <span class="token keyword">class</span> 的锁。因为静态成员不属于任何一个实例对象，是类成员（ <span class="token keyword">static</span> 表明这是该类的一个静态资源，不管 <span class="token keyword">new</span> 了多少个对象，只有一份）。所以，如果一个线程 <span class="token class-name">A</span> 调用一个实例对象的非静态 `<span class="token keyword">synchronized</span>` 方法，而线程 <span class="token class-name">B</span> 需要调用这个实例对象所属类的静态 `<span class="token keyword">synchronized</span>` 方法，是允许的，不会发生互斥现象，因为访问静态 `<span class="token keyword">synchronized</span>` 方法占用的锁是当前类的锁，而访问非静态 `<span class="token keyword">synchronized</span>` 方法占用的锁是当前实例对象锁。  ```java<span class="token keyword">synchronized</span> <span class="token keyword">void</span> staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.修饰代码块 ：指定加锁对象，对给定对象/类加锁。 <code>synchronized(this|object)</code> 表示进入同步代码<br>库前要获得给定对象的锁。 <code>synchronized(类.class)</code> 表示进入同步代码前要获得 当前 class 的锁<br><strong>总结</strong>  </p><ul><li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class<br>类上锁。</li><li>synchronized 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！  <h2 id="4-synchronized底层原理？"><a href="#4-synchronized底层原理？" class="headerlink" title="4.synchronized底层原理？"></a>4.synchronized底层原理？</h2><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和<code> monitorexit</code> 指令，其中<br><code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束位<br>置。<br><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是<br><code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。  </li></ul><p><strong>不过两者的本质都是对对象监视器 <code>monitor</code> 的获取。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客解决图片不显示问题</title>
      <link href="//pages/c003/"/>
      <url>//pages/c003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于在使用hexo搭建博客过程中遇到了图片不显示的问题，本篇就详细解释一下。（windows）  </p></blockquote><p>在项目根目录下打开cmd，输入<code>hexo new xxx</code>之后会在根目录下创建一个xxx.md文件和xxx的文件夹，我们可以把<br>图片放到xxx文件夹内，然后在xxx.md文件内引入，引入的方式如下：  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>test<span class="token punctuation">]</span><span class="token punctuation">(</span>test.png<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>是不需要带上相对路径的</em><br><strong>但是它有一些前提条件！！！</strong></p><ol><li>安装插件，在项目根目录下打开cmd，然后输入下面命令<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改主页配置文件，把_config.yml里的post_asset_folder:这个选项设置为true</li><li>使用<code>hexo new xxx</code>来生成博客和它的文件夹，图片就放到相应的文件夹即可<blockquote><p>测试一下</p></blockquote></li></ol><p><img src="/pages/c003/a.jpg" alt="test"></p>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的分布式锁简单实现</title>
      <link href="//pages/c002/"/>
      <url>//pages/c002/</url>
      
        <content type="html"><![CDATA[<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，<br>这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，<br>这就是分布式锁要解决的问题！<br>分布式锁主流实现方案：  </p><ul><li>基于数据库实现分布式锁</li><li>基于缓存(Redis)</li><li>基于Zookeeper  </li></ul><p>每一种分布式锁解决方案都有各自的优缺点：</p><ul><li>性能：Redis最高</li><li>可靠性：zookeeper最高<blockquote><p>下面讲一下基于redis实现的分布式锁</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> lock <span class="token number">200</span> nx ex <span class="token number">10</span><span class="token comment"># EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</span><span class="token comment"># PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</span><span class="token comment"># NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</span><span class="token comment"># XX ：只在键已经存在时，才对键进行设置操作。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/pages/c002/c002_01.png" alt="dis1">  </li></ul><ol><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试  <blockquote><p>示例代码：</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//1获取锁，setnx</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2获取锁成功、查询num的值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//2.4释放锁，del</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token comment">//3获取锁失败、每隔0.1秒再获取</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>解决：设置lock过期时间，自动释放锁。  <blockquote><p>优化，设置锁的过期时间  </p></blockquote></li></ol><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）<br><img src="/pages/c002/c002_02.png" alt="dis2"><br>示例代码：  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//在redis中使用setnx  设置lock,并且设置过期时间3秒</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"chenjian"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此处模拟业务异常情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">==</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4 释放锁</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>问题：可能会释放其他服务器的锁。 </li></ol><p> 场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑 </li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p> 最终等于没锁的情况。<br> <strong>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</strong></p><blockquote><p>优化之UUID防误删</p></blockquote><p><img src="/pages/c002/c002_03.png" alt="dis3"><br>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在redis中使用setnx  设置lock,并且设置过期时间3秒</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.2有值就转成成int</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此处模拟业务异常情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">==</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4 释放锁</span>        <span class="token class-name">String</span> lockValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建hexo+github博客</title>
      <link href="//pages/c001/"/>
      <url>//pages/c001/</url>
      
        <content type="html"><![CDATA[<ul><li>首先使用如下命令安装hexo-cli，看名字就知道Hexo的CLI工具；</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装成功后初始化一个博客目录，并进入该目录，然后安装依赖；</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 初始化博客目录</span>hexo init website-hexo<span class="token comment"># 进入博客目录</span><span class="token builtin class-name">cd</span> website-hexo<span class="token comment"># 安装博客相关依赖</span><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这样一个基本的博客网站就搭建完毕了，是不是秒建博客网站，然后使用如下命令启动博客网站:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>启动成功后我们可以访问下主页，用过Hexo的朋友应该知道，Hexo要搭配主题来使用，否则真的很丑，访问地址：<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="/pages/c001/blog.png" alt="myblog"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/10/hello-world/"/>
      <url>/2022/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
